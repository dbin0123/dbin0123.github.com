<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>2021年03月06日 《深入浅出 Java 多线程》第一篇 基础篇 | 被讨厌的勇气</title><meta name="author" content="aiwiown"><meta name="copyright" content="aiwiown"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="深入浅出 Java 多线程》第一篇 基础篇">
<meta property="og:type" content="article">
<meta property="og:title" content="2021年03月06日 《深入浅出 Java 多线程》第一篇 基础篇">
<meta property="og:url" content="http://blog.aiwiown.com/2021/03/06/2021/202103/2021-03-06-java_thread_101/index.html">
<meta property="og:site_name" content="被讨厌的勇气">
<meta property="og:description" content="深入浅出 Java 多线程》第一篇 基础篇">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/03/06/zEfkNQaWPJYIbAV.jpg">
<meta property="article:published_time" content="2021-03-05T16:00:00.000Z">
<meta property="article:modified_time" content="2023-08-27T11:01:20.113Z">
<meta property="article:author" content="aiwiown">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/03/06/zEfkNQaWPJYIbAV.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.aiwiown.com/2021/03/06/2021/202103/2021-03-06-java_thread_101/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?15ff47592d52309a90efe9e6975528ae";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '2021年03月06日 《深入浅出 Java 多线程》第一篇 基础篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-27 19:01:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/self/duotone.css"><meta name="generator" content="Hexo 6.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/03/06/zEfkNQaWPJYIbAV.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">80</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">131</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">66</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="被讨厌的勇气"><span class="site-name">被讨厌的勇气</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">2021年03月06日 《深入浅出 Java 多线程》第一篇 基础篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-05T16:00:00.000Z" title="发表于 2021-03-06 00:00:00">2021-03-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-27T11:01:20.113Z" title="更新于 2023-08-27 19:01:20">2023-08-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">java多线程</a></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><h3 id="第一章-进程与线程的基本概念"><a href="#第一章-进程与线程的基本概念" class="headerlink" title="第一章 进程与线程的基本概念"></a>第一章 进程与线程的基本概念</h3><h4 id="1-1-进程产生的背景"><a href="#1-1-进程产生的背景" class="headerlink" title="1.1 进程产生的背景"></a>1.1 进程产生的背景</h4><ul>
<li>进程:应用程序在内存中分配的空间，也就是正在运行的程序<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">进程中CPU采用时间片轮转的方式运行进程：CPU为每个进程分配一个时间段，称作它的时间片<br></code></pre></td></tr></table></figure></li>
<li>上下文切换:进程&#x2F;线程中CPU来回切换被称为上下问切换<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">进程让操作系统的并发性成为了可能，而线程让进程的内部并发成为了可能<br></code></pre></td></tr></table></figure></li>
</ul>
<p>多进程方式确实可以实现并发，但使用多线程，有以下几个好处：</p>
<ol>
<li>进程间的通信比较复杂，而线程间的通信比较简单，通常情况下，我们需要使用共享资源，这些资源在线程间的通信比较容易。</li>
<li>进程是重量级的，而线程是轻量级的，故多线程方式的系统开销更小。</li>
</ol>
<ul>
<li>进程和线程的区别(本质的区别是<strong>是否单独占有内存地址空间及其它系统资源（比如I&#x2F;O）</strong>)<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1. 进程间单独占用内存地址,各进程进不相互干扰; <br>2. 一个进程不可用不会影响其他进程;<br>3. 占用内存大小不一样(进程占用内存大,开销大,线程只需要保存寄存器和栈信息，开销较小);<br></code></pre></td></tr></table></figure>
++<strong>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位，即CPU分配时间的单位</strong>++</li>
</ul>
<h4 id="1-2-上下文切换-程序计数器"><a href="#1-2-上下文切换-程序计数器" class="headerlink" title="1.2 上下文切换(&#x3D;&#x3D;程序计数器&#x3D;&#x3D;)"></a>1.2 上下文切换(<strong>&#x3D;&#x3D;程序计数器&#x3D;&#x3D;</strong>)</h4><p>上下文切换（有时也称做进程切换或任务切换）是指 CPU 从一个进程（或线程）切换到另一个进程（或线程）。上下文是指某一时间点 CPU 寄存器和程序计数器的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">举例说明 线程A - B<br>1.先挂起线程A，将其在cpu中的状态保存在内存中。<br>2.在内存中检索下一个线程B的上下文并将其在 CPU 的寄存器中恢复,执行B线程。<br>3.当B执行完，根据程序计数器中指向的位置恢复线程A。<br></code></pre></td></tr></table></figure>

<p>上下文切换将<strong>消耗大量的 CPU 时间，++故线程也不是越多越好++</strong></p>
<h3 id="第二章-Java多线程入门类和接口"><a href="#第二章-Java多线程入门类和接口" class="headerlink" title="第二章 Java多线程入门类和接口"></a>第二章 Java多线程入门类和接口</h3><p>JDK提供了Thread类和Runnable接口来让我们实现自己的“线程”类</p>
<h4 id="2-1-继承Thread类-jdk8演示-后续代码没有特殊说明都使用jdk8"><a href="#2-1-继承Thread类-jdk8演示-后续代码没有特殊说明都使用jdk8" class="headerlink" title="2.1 继承Thread类(jdk8演示(后续代码没有特殊说明都使用jdk8))"></a>2.1 继承Thread类(jdk8演示(后续代码没有特殊说明都使用jdk8))</h4><ul>
<li>继承Thread接口,重写run方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import java.util.concurrent.TimeUnit;<br><br>/**<br> * @ClassName : ExtendThread<br> * @Description : 继承Thread类实现多线程<br> * @Author : dbin0123<br> * @Date: 2021-03-02 22:44<br> */<br>public class ExtendThread extends Thread &#123;<br><br>    @Override<br>    public void run() &#123;<br>        //需要线程执行的代码<br>        System.out.println(&quot;线程ID:&quot; + this.getId() + &quot;, 线程名称:&quot; + this.getName());<br>    &#125;<br><br>    public static void main(String[] args) throws InterruptedException &#123;<br>        Thread mainThread = Thread.currentThread();<br>        System.out.println(&quot;主线程运行, 线程ID:&quot; + mainThread.getId() + &quot;, 线程名称:&quot; + mainThread.getName());<br>        ExtendThread thread = new ExtendThread();<br>        //注意不可多次调用start()方法。在第一次调用start()方法后，再次调用start()方法会抛出异常<br>        thread.start();<br>        TimeUnit.SECONDS.sleep(20);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">主线程运行, 线程ID:1, 线程名称:main<br>线程ID:12, 线程名称:Thread-0<br></code></pre></td></tr></table></figure>

<h5 id="2-1-1-Thread-init方法介绍"><a href="#2-1-1-Thread-init方法介绍" class="headerlink" title="2.1.1 Thread.init方法介绍"></a>2.1.1 Thread.init方法介绍</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/**<br> * Initializes a Thread.<br> *<br> * @param g the Thread group<br> * @param target the object whose run() method gets called<br> * @param name the name of the new Thread<br> * @param stackSize the desired stack size for the new thread, or<br> *        zero to indicate that this parameter is to be ignored.<br> * @param acc the AccessControlContext to inherit, or<br> *            AccessController.getContext() if null<br> * @param inheritThreadLocals if &#123;@code true&#125;, inherit initial values for<br> *            inheritable thread-locals from the constructing thread<br> */<br>private void init(ThreadGroup g, Runnable target, String name,<br>                  long stackSize, AccessControlContext acc,<br>                  boolean inheritThreadLocals)&#123;<br>                      //......<br>                  &#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>ThreadGroup g:线程组，指定这个线程是在哪个线程组下；</li>
<li>Runnable target:指定要执行的任务；</li>
<li>String name:线程的名字，多个线程的名字是可以重复的。如果不指定名字,使用( “Thread-“ + nextThreadNum())生成</li>
<li>long stackSize:新线程所需的堆栈大小，或者0表示该参数将被忽略。</li>
<li>AccessControlContext acc:一般我们是不会使用它的，那什么时候会使用到这个变量呢？可以参考这个stackoverflow的问题：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/13516766/restrict-permissions-to-threads-which-execute-third-party-software">Restrict permissions to threads which execute third party software</a></li>
<li>boolean inheritThreadLocals:可继承的ThreadLocal，见片段4，Thread类里面有两个私有属性来支持ThreadLocal，我们会在后面的章节介绍ThreadLocal的概念</li>
</ul>
<p>Thread类的几个常用的方法：</p>
<ul>
<li>currentThread()：静态方法，返回对当前正在执行的线程对象的引用；</li>
<li>start()：开始执行线程的方法，java虚拟机会调用线程内的run()方法；</li>
<li>yield()：yield在英语里有放弃的意思，同样，这里的yield()指的是当前线程愿意让出对当前处理器的占用。**++这里需要注意的是++，就算当前线程调用了yield()方法，程序在调度的时候，也还有可能继续运行这个线程的**；</li>
<li>sleep()：静态方法，使当前线程睡眠一段时间；</li>
<li>join()：使当前线程等待另一个线程执行完毕之后再继续执行，内部调用的是Object类的wait方法实现的；</li>
</ul>
<h4 id="2-2-实现Runnable接口"><a href="#2-2-实现Runnable接口" class="headerlink" title="2.2 实现Runnable接口"></a>2.2 实现Runnable接口</h4><ul>
<li>实现Runnable接口,实现run方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import java.util.concurrent.TimeUnit;<br><br>/**<br> * @ClassName : ImplRunnable<br> * @Description : 实现Runnable接口实现多线程<br> * @Author : dbin0123<br> * @Date: 2021-03-02 22:52<br> */<br>public class ImplRunnable implements Runnable&#123;<br>    @Override<br>    public void run() &#123;<br>        //需要线程执行的代码<br>        Thread thread = Thread.currentThread();<br>        System.out.println(&quot;线程ID:&quot; + thread.getId() + &quot;, 线程名称:&quot; + thread.getName());<br>    &#125;<br><br>    public static void main(String[] args) throws InterruptedException &#123;<br>        Thread mainThread = Thread.currentThread();<br>        System.out.println(&quot;主线程运行, 线程ID:&quot; + mainThread.getId() + &quot;, 线程名称:&quot; + mainThread.getName());<br>        Thread thread = new Thread(new ImplRunnable());<br>        thread.start();<br>        TimeUnit.SECONDS.sleep(20);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">主线程运行, 线程ID:1, 线程名称:main<br>线程ID:12, 线程名称:Thread-0<br></code></pre></td></tr></table></figure>


<h4 id="2-3-Callable、Future与FutureTask"><a href="#2-3-Callable、Future与FutureTask" class="headerlink" title="2.3 Callable、Future与FutureTask"></a>2.3 Callable、Future与FutureTask</h4><p>JDK提供了Callable接口与Future接口为我们解决这个问题，这也是所谓的“异步”模型。</p>
<h5 id="Callable-接口"><a href="#Callable-接口" class="headerlink" title="Callable 接口"></a>Callable 接口</h5><p>Callable与Runnable类似，同样是只有一个抽象方法的函数式接口。不同的是，Callable提供的方法是有返回值的，而且支持泛型。Callable一般是配合线程池工具ExecutorService来使用的;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">public interface Callable&lt;V&gt; &#123;<br>    V call() throws Exception;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import java.util.concurrent.Callable;<br>import java.util.concurrent.ExecutionException;<br>import java.util.concurrent.ExecutorService;<br>import java.util.concurrent.Executors;<br>import java.util.concurrent.Future;<br><br>/**<br> * @ClassName : CallableThread<br> * @Description : 使用Callable实现多线程<br> * @Author : dbin0123<br> * @Date: 2021-03-02 23:16<br> */<br>public class CallableThread implements Callable&lt;String&gt; &#123;<br>    /**<br>     * 执行方法<br>     *<br>     * @return<br>     * @throws Exception<br>     */<br>    @Override<br>    public String call() throws Exception &#123;<br>        //需要线程执行的代码<br>        Thread thread = Thread.currentThread();<br>        System.out.println(&quot;线程ID:&quot; + thread.getId() + &quot;, 线程名称:&quot; + thread.getName());<br>        return &quot;OK&quot;;<br>    &#125;<br><br>    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;<br>        Thread mainThread = Thread.currentThread();<br>        System.out.println(&quot;主线程运行, 线程ID:&quot; + mainThread.getId() + &quot;, 线程名称:&quot; + mainThread.getName());<br>        ExecutorService executor = Executors.newSingleThreadExecutor();<br>        Future&lt;String&gt; submit = executor.submit(new CallableThread());<br>        System.out.println(&quot;线程相应:&quot; + submit.get());<br>        executor.shutdown();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>响应数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">主线程运行, 线程ID:1, 线程名称:main<br>线程ID:12, 线程名称:pool-1-thread-1<br>线程相应:OK<br></code></pre></td></tr></table></figure>
<h5 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">public abstract interface Future&lt;V&gt; &#123;<br>    public abstract boolean cancel(boolean paramBoolean);<br>    public abstract boolean isCancelled();<br>    public abstract boolean isDone();<br>    public abstract V get() throws InterruptedException, ExecutionException;<br>    public abstract V get(long paramLong, TimeUnit paramTimeUnit)<br>            throws InterruptedException, ExecutionException, TimeoutException;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>cancel方法是试图取消一个线程的执行。</p>
<p>注意是试图取消，并不一定能取消成功。因为任务可能已完成、已取消、或者一些其它因素不能取消，存在取消失败的可能。boolean类型的返回值是“是否取消成功”的意思。参数paramBoolean表示是否采用中断的方式取消线程执行( true如果执行该任务的线程应该被中断; 否则，正在进行的任务被允许完成)。</p>
<p>所以有时候，为了让任务有能够取消的功能，就使用Callable来代替Runnable。如果为了可取消性而使用 Future但又不提供可用的结果，则可以声明 Future&lt;?&gt;形式类型、并返回 null作为底层任务的结果。</p>
<h5 id="FutureTask类"><a href="#FutureTask类" class="headerlink" title="FutureTask类"></a>FutureTask类</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import java.util.concurrent.Callable;<br>import java.util.concurrent.ExecutionException;<br>import java.util.concurrent.ExecutorService;<br>import java.util.concurrent.Executors;<br>import java.util.concurrent.FutureTask;<br><br>/**<br> * @ClassName : FutureTaskThread<br> * @Description : FutureTask实现多线程<br> * @Author : dbin0123<br> * @Date: 2021-03-02 23:25<br> */<br>public class FutureTaskThread implements Callable&lt;String&gt; &#123;<br>    @Override<br>    public String call() throws Exception &#123;<br>        //需要线程执行的代码<br>        Thread thread = Thread.currentThread();<br>        System.out.println(&quot;线程ID:&quot; + thread.getId() + &quot;, 线程名称:&quot; + thread.getName());<br>        return &quot;OK&quot;;<br>    &#125;<br><br>    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;<br>        Thread mainThread = Thread.currentThread();<br>        System.out.println(&quot;主线程运行, 线程ID:&quot; + mainThread.getId() + &quot;, 线程名称:&quot; + mainThread.getName());<br>        ExecutorService executor = Executors.newCachedThreadPool();<br>        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(new FutureTaskThread());<br>        //此时调用submit是没返回值的,可以通过futureTask获取<br>        executor.submit(futureTask);<br>        //Future.get方法会阻塞直到获取线程相应数据<br>        System.out.println(&quot;线程响应:&quot; + futureTask.get());<br>        executor.shutdown();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>响应:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">主线程运行, 线程ID:1, 线程名称:main<br>线程ID:12, 线程名称:pool-1-thread-1<br>线程响应:OK<br></code></pre></td></tr></table></figure>

<p>在很多高并发的环境下，有可能Callable和FutureTask会创建多次。FutureTask能够在高并发环境下确保任务只执行一次。这块有兴趣的同学可以参看FutureTask源码。</p>
<h6 id="FutureTask的几个状态"><a href="#FutureTask的几个状态" class="headerlink" title="FutureTask的几个状态"></a>FutureTask的几个状态</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/**<br>  *<br>  * state可能的状态转变路径如下：<br>  * NEW -&gt; COMPLETING -&gt; NORMAL<br>  * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL<br>  * NEW -&gt; CANCELLED<br>  * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED<br>  */<br>private volatile int state;<br>private static final int NEW          = 0;<br>private static final int COMPLETING   = 1;<br>private static final int NORMAL       = 2;<br>private static final int EXCEPTIONAL  = 3;<br>private static final int CANCELLED    = 4;<br>private static final int INTERRUPTING = 5;<br>private static final int INTERRUPTED  = 6;<br></code></pre></td></tr></table></figure>

<p>state表示任务的运行状态，初始状态为NEW。运行状态只会在set、setException、cancel方法中终止。COMPLETING、INTERRUPTING是任务完成后的瞬时状态。</p>
<h4 id="第三章-线程组和线程优先级"><a href="#第三章-线程组和线程优先级" class="headerlink" title="第三章 线程组和线程优先级"></a>第三章 线程组和线程优先级</h4><h5 id="3-1-线程组-ThreadGroup"><a href="#3-1-线程组-ThreadGroup" class="headerlink" title="3.1 线程组(ThreadGroup)"></a>3.1 线程组(ThreadGroup)</h5><p>Java中用ThreadGroup来表示线程组，我们可以使用线程组对线程进行批量控制。每个Thread必然存在于一个ThreadGroup中，Thread不能独立于ThreadGroup存在。执行main()方法线程的名字是main(默认)，如果在new Thread时没有显式指定，那么默认将父线程（当前执行new Thread的线程）线程组设置为自己的线程组。</p>
<p>示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/**<br> * @ClassName : ThreadGroup<br> * @Description : 线程组<br> * @Author : dbin0123<br> * @Date: 2021-03-03 21:08<br> */<br>public class ThreadGroup implements Runnable &#123;<br><br><br>    @Override<br>    public void run() &#123;<br>        Thread thread = Thread.currentThread();<br>        java.lang.ThreadGroup threadGroup = thread.getThreadGroup();<br>        System.out.println(&quot;run方法中的threadName:&quot; + thread.getName() + &quot;,threadGroupName：&quot; + threadGroup.getName());<br>    &#125;<br><br>    public static void main(String[] args) &#123;<br>        new Thread(new ThreadGroup()).start();<br>        Thread thread = Thread.currentThread();<br>        java.lang.ThreadGroup threadGroup = thread.getThreadGroup();<br>        System.out.println(&quot;main方法中的threadName:&quot; + thread.getName() + &quot;,threadGroupName：&quot; + threadGroup.getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>响应：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">main方法中的threadName:main,threadGroupName：main<br>run方法中的threadName:Thread-0,threadGroupName：main<br></code></pre></td></tr></table></figure>
<p>ThreadGroup管理着它下面的Thread，<strong>ThreadGroup是一个标准的向下引用的树状结构，这样设计的原因是防止”上级”线程被”下级”线程引用而无法有效地被GC回收</strong></p>
<h5 id="3-2-线程的优先级"><a href="#3-2-线程的优先级" class="headerlink" title="3.2 线程的优先级"></a>3.2 线程的优先级</h5><p>Java中线程优先级可以指定，范围是1~10。Java默认的线程优先级为5, 但是并不是所有的操作系统都支持10级优先级的划分（比如有些操作系统只支持3级划分：低，中，高），Java只是给操作系统一个优先级的参考值，线程最终在操作系统的优先级是多少还是由操作系统决定。线程的优先级会在线程被调用之前设定。</p>
<p>通常情况下，高优先级的线程将会比低优先级的线程有更高的几率得到执行。我们使用方法Thread类的&#x3D;&#x3D;setPriority()&#x3D;&#x3D;实例方法来设定线程的优先级。<br><strong>Java程序中对线程所设置的优先级只是给操作系统一个建议，操作系统不一定会采纳。而真正的调用顺序，是由操作系统的线程调度算法决定的</strong></p>
<p><strong>如果某个线程优先级大于线程所在线程组的最大优先级，那么该线程的优先级将会失效，取而代之的是线程组的最大优先级</strong><br>示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/**<br> * @ClassName : ThreadPriority<br> * @Description : 线程优先级设置<br> * @Author : dbin0123<br> * @Date: 2021-03-03 21:16<br> */<br>public class ThreadPriority implements Runnable &#123;<br>    @Override<br>    public void run() &#123;<br>        Thread thread = Thread.currentThread();<br>        System.out.println(&quot;当前线程名称:&quot; + thread.getName() + &quot;, 当前线程组:&quot; + thread.getThreadGroup().getName() + &quot;, 当前线程级别:&quot; + thread.getPriority());<br>    &#125;<br><br>    public static void main(String[] args) &#123;<br>        Thread thread = Thread.currentThread();<br>        System.out.println(&quot;main方法,当前线程级别:&quot; + thread.getPriority());<br><br>        Thread priorityThread = new Thread(new ThreadPriority());<br>        priorityThread.setPriority(10);<br>        priorityThread.start();<br><br>        java.lang.ThreadGroup threadGroup = new java.lang.ThreadGroup(&quot;thread-group-01&quot;);<br>        threadGroup.setMaxPriority(5);<br>        Thread threadGroupPriorityThread = new Thread(threadGroup, new ThreadPriority());<br>        threadGroupPriorityThread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>响应数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">main方法,当前线程级别:5<br>当前线程名称:Thread-0, 当前线程组:main, 当前线程级别:10<br>当前线程名称:Thread-1, 当前线程组:thread-group-01, 当前线程级别:5<br></code></pre></td></tr></table></figure>

<p>线程优先级示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/**<br> * @ClassName : ThreadPriority2<br> * @Description : 线程优先级2<br> * @Author : dbin0123<br> * @Date: 2021-03-03 21:33<br> */<br>public class ThreadPriority2 extends Thread &#123;<br><br>    public ThreadPriority2(String name) &#123;<br>        super(name);<br>    &#125;<br><br>    @Override<br>    public void run() &#123;<br>        Thread thread = Thread.currentThread();<br>        System.out.println(String.format(&quot;当前执行的线程是：%s，优先级：%d&quot;, thread.getName(), thread.getPriority()));<br>    &#125;<br><br>    public static void main(String[] args) &#123;<br>        for (int i = 1; i &lt;= 10; i++) &#123;<br>            ThreadPriority2 threadPriority2 = new ThreadPriority2(&quot;线程名称 &quot; + i);<br>            threadPriority2.setPriority(i);<br>            threadPriority2.start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>响应(&#x3D;&#x3D;说明不是线程的优先级越高就一定越先执行&#x3D;&#x3D;)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">当前执行的线程是：线程名称 7，优先级：7<br>当前执行的线程是：线程名称 1，优先级：1<br>当前执行的线程是：线程名称 2，优先级：2<br>当前执行的线程是：线程名称 4，优先级：4<br>当前执行的线程是：线程名称 6，优先级：6<br>当前执行的线程是：线程名称 5，优先级：5<br>当前执行的线程是：线程名称 3，优先级：3<br>当前执行的线程是：线程名称 10，优先级：10<br>当前执行的线程是：线程名称 9，优先级：9<br>当前执行的线程是：线程名称 8，优先级：8<br></code></pre></td></tr></table></figure>
<ul>
<li>守护线程（Daemon）<br>线程分为两种，<strong>用户线程</strong>和<strong>守护线程</strong><br>守护线程和用户线程区别不大，可以理解为特殊的用户线程。特殊就特殊在如果程序中所有的用户线程都退出了，那么所有的守护线程就都会被杀死，很好理解，没有被守护的对象了，也不需要守护线程了<br>创建守护线程的两种方式</li>
</ul>
<ol>
<li>thread.setDaemon(true);&#x2F;&#x2F;必须在线程启动start()方法之前设置</li>
<li>Timer timer &#x3D; new Timer(true)</li>
</ol>
<h5 id="3-3-线程组的常用方法"><a href="#3-3-线程组的常用方法" class="headerlink" title="3.3 线程组的常用方法"></a>3.3 线程组的常用方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">public class ThreadGroup implements Thread.UncaughtExceptionHandler &#123;<br>    private final ThreadGroup parent; // 父亲ThreadGroup<br>    String name; // ThreadGroupr 的名称<br>    int maxPriority; // 线程最大优先级<br>    boolean destroyed; // 是否被销毁<br>    boolean daemon; // 是否守护线程<br>    boolean vmAllowSuspension; // 是否可以中断<br><br>    int nUnstartedThreads = 0; // 还未启动的线程<br>    int nthreads; // ThreadGroup中线程数目<br>    Thread threads[]; // ThreadGroup中的线程<br><br>    int ngroups; // 线程组数目<br>    ThreadGroup groups[]; // 线程组数组<br>    <br>    // 检查parent ThreadGroup<br>    private static Void checkParentAccess(ThreadGroup parent) &#123;<br>        parent.checkAccess();<br>        return null;<br>    &#125;<br><br>    // 判断当前运行的线程是否具有修改线程组的权限<br>    public final void checkAccess() &#123;<br>        SecurityManager security = System.getSecurityManager();<br>        if (security != null) &#123;<br>            security.checkAccess(this);<br>        &#125;<br>    &#125;<br>    //.....<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<h4 id="第四章-Java线程的状态及主要转化方法"><a href="#第四章-Java线程的状态及主要转化方法" class="headerlink" title="第四章 Java线程的状态及主要转化方法"></a>第四章 Java线程的状态及主要转化方法</h4><h5 id="4-1-Java线程的6个状态"><a href="#4-1-Java线程的6个状态" class="headerlink" title="4.1 Java线程的6个状态"></a>4.1 Java线程的6个状态</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">// Thread.State 源码<br>public enum State &#123;<br>    NEW,<br>    RUNNABLE,<br>    BLOCKED,<br>    WAITING,<br>    TIMED_WAITING,<br>    TERMINATED;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>NEW(new) :处于NEW状态的线程此时尚未启动。这里的尚未启动指的是还没调用Thread实例的start()方法<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">private void testStateNew() &#123;<br>    Thread thread = new Thread(() -&gt; &#123;&#125;);<br>    System.out.println(thread.getState()); // 输出 NEW <br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>RUNNABLE(runnable):表示当前线程正在运行中。处于RUNNABLE状态的线程在Java虚拟机中运行，也有可能在等待CPU分配资源</li>
<li>BLOCKED(blocked):阻塞状态。处于BLOCKED状态的线程正等待锁的释放以进入同步区。</li>
<li>WAITING(waiting):等待状态。处于等待状态的线程变成RUNNABLE状态需要其他线程唤醒。<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1. Object.wait()：使当前线程处于等待状态直到另一个线程唤醒它；<br>2. Thread.join()：等待线程执行完毕，底层调用的是Object实例的wait方法；<br>3. LockSupport.park()：除非获得调用许可，否则禁用当前线程进行线程调度。<br></code></pre></td></tr></table></figure></li>
<li>TIMED_WAITING(time_waiting):超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Thread.sleep(long millis)：使当前线程睡眠指定时间；<br>Object.wait(long timeout)：线程休眠指定时间，等待期间可以通过notify()/notifyAll()唤醒；<br>Thread.join(long millis)：等待当前线程最多执行millis毫秒，如果millis为0，则会一直执行；<br>LockSupport.parkNanos(long nanos)： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；<br>LockSupport.parkUntil(long deadline)：同上，也是禁止线程进行调度指定时间；<br></code></pre></td></tr></table></figure></li>
<li>TERMINATED(terminated):终止状态。此时线程已执行完毕。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://concurrent.redspider.group/article/01/imgs/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png" alt="image"></li>
</ul>
<h5 id="4-2-BLOCKED与RUNNABLE状态的转换"><a href="#4-2-BLOCKED与RUNNABLE状态的转换" class="headerlink" title="4.2 BLOCKED与RUNNABLE状态的转换"></a>4.2 BLOCKED与RUNNABLE状态的转换</h5><p>示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/**<br> * @ClassName : ThreadStatusBlocked<br> * @Description : 线程阻塞状态转运行状态<br> * @Author : dbin0123<br> * @Date: 2021-03-03 21:58<br> */<br>public class ThreadStatusBlocked implements Runnable&#123;<br>    private static Object obj = new Object();<br>    @Override<br>    public void run() &#123;<br>        synchronized (obj)  &#123;<br>            try &#123;<br>                Thread.sleep(4000L);//使1线程进入TIMED_WAITING(超时等等状态)<br>            &#125; catch (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    public static void main(String[] args) throws InterruptedException &#123;<br>        Thread threadBlocked01 = new Thread(new ThreadStatusBlocked(), &quot;1&quot;);<br>        Thread threadBlocked02 = new Thread(new ThreadStatusBlocked(), &quot;2&quot;);<br>        threadBlocked01.start();<br>        Thread.sleep(3000L);<br>        threadBlocked02.start();//线程2等等obj锁 BLOCKED(锁定)<br>        System.out.println(threadBlocked01.getName() + &quot;:&quot; + threadBlocked01.getState());<br>        System.out.println(threadBlocked02.getName() + &quot;:&quot; + threadBlocked02.getState());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1:TIMED_WAITING<br>2:BLOCKED<br></code></pre></td></tr></table></figure>
<ul>
<li>状态流转<ul>
<li>1的状态转换过程：RUNNABLE（1.start()） -&gt; TIMED_WATING（Thread.sleep()）-&gt;RUNABLE（sleep()时间到）-&gt;BLOCKED(未抢到锁) -&gt; TERMINATED</li>
<li>2的状态转换过程：RUNNABLE（2.start()) -&gt; BLOCKED(未抢到锁) -&gt;TERMINATED</li>
</ul>
</li>
</ul>
<h5 id="4-3-WAITING状态与RUNNABLE状态的转换"><a href="#4-3-WAITING状态与RUNNABLE状态的转换" class="headerlink" title="4.3 WAITING状态与RUNNABLE状态的转换"></a>4.3 WAITING状态与RUNNABLE状态的转换</h5><p>根据转换图我们知道有3个方法可以使线程从RUNNABLE状态转为WAITING状态。</p>
<ul>
<li>Object.wait()&#x2F;&#x2F;<strong>&#x3D;&#x3D;线程必须持有锁,调用wait方法会主动释放锁;&#x3D;&#x3D;</strong></li>
</ul>
<p>调用wait()方法前线程必须持有对象的锁。</p>
<p>线程调用wait()方法时，会释放当前的锁，直到有其他线程调用notify()&#x2F;notifyAll()方法唤醒等待锁的线程。</p>
<p>需要注意的是，其他线程调用notify()方法只会唤醒单个等待锁的线程，如有有多个线程都在等待这个锁的话不一定会唤醒到之前调用wait()方法的线程。</p>
<p>同样，调用notifyAll()方法唤醒所有等待锁的线程之后，也不一定会马上把时间片分给刚才放弃锁的那个线程，具体要看系统的调度。</p>
<ul>
<li>Thread.join()</li>
</ul>
<p>调用join()方法不会释放锁，会一直等待当前线程执行完毕（转换为TERMINATED状态）。</p>
<p>join方法示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/**<br> * @ClassName : ThreadStatusBlocked<br> * @Description : 线程阻塞状态转运行状态<br> * @Author : dbin0123<br> * @Date: 2021-03-03 21:58<br> */<br>public class ThreadStatusJoin implements Runnable&#123;<br>    private static Object obj = new Object();<br>    @Override<br>    public void run() &#123;<br>        synchronized (obj)  &#123;<br>            try &#123;<br>                Thread.sleep(4000L);<br>            &#125; catch (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    public static void main(String[] args) throws InterruptedException &#123;<br>        Thread threadBlocked01 = new Thread(new ThreadStatusJoin(), &quot;1&quot;);<br>        Thread threadBlocked02 = new Thread(new ThreadStatusJoin(), &quot;2&quot;);<br>        threadBlocked01.start();<br>        //不会释放锁，会一直等待当前线程执行完毕<br>        threadBlocked01.join();<br>        threadBlocked02.start();//线程2等等obj锁 BLOCKED(锁定)<br>        System.out.println(threadBlocked01.getName() + &quot;:&quot; + threadBlocked01.getState());<br>        System.out.println(threadBlocked02.getName() + &quot;:&quot; + threadBlocked02.getState());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>响应</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1:TERMINATED<br>2:TIMED_WAITING(可能卡在Thread.sleep(4000L);)<br></code></pre></td></tr></table></figure>

<h5 id="4-4-TIMED-WAITING与RUNNABLE状态转换"><a href="#4-4-TIMED-WAITING与RUNNABLE状态转换" class="headerlink" title="4.4 TIMED_WAITING与RUNNABLE状态转换"></a>4.4 TIMED_WAITING与RUNNABLE状态转换</h5><p>TIMED_WAITING与WAITING状态类似，只是TIMED_WAITING状态等待的时间是指定的。</p>
<ul>
<li>Thread.sleep(long)</li>
</ul>
<p>使当前线程睡眠指定时间。需要注意这里的“睡眠”只是暂时使线程停止执行，并不会释放锁。时间到后，线程会重新进入RUNNABLE状态。</p>
<ul>
<li>Object.wait(long)</li>
</ul>
<p>wait(long)方法使线程进入TIMED_WAITING状态。这里的wait(long)方法与无参方法wait()相同的地方是，都可以通过其他线程调用notify()或notifyAll()方法来唤醒。</p>
<p>不同的地方是，有参方法wait(long)就算其他线程不来唤醒它，经过指定时间long之后它会自动唤醒，拥有去争夺锁的资格。</p>
<ul>
<li>Thread.join(long)</li>
</ul>
<p>join(long)使当前线程执行指定时间，并且使线程进入TIMED_WAITING状态。</p>
<h5 id="4-5-线程中断"><a href="#4-5-线程中断" class="headerlink" title="4.5 线程中断"></a>4.5 线程中断</h5><ul>
<li>Thread.interrupt()：中断线程。这里的中断线程并不会立即停止线程，而是设置线程的中断状态为true（默认是flase）；</li>
<li>Thread.interrupted()：测试当前线程是否被中断。线程的中断状态受这个方法的影响，意思是调用一次使线程中断状态设置为true，连续调用两次会使得这个线程的中断状态重新转为false；</li>
<li>Thread.isInterrupted()：测试当前线程是否被中断。与上面方法不同的是调用这个方法并不会影响线程的中断状态。</li>
</ul>
<h4 id="第五章-Java线程间的通信"><a href="#第五章-Java线程间的通信" class="headerlink" title="第五章 Java线程间的通信"></a>第五章 Java线程间的通信</h4><p>合理的使用Java多线程可以更好地利用服务器资源。一般来讲，线程内部有自己私有的线程上下文，互不干扰。但是当我们需要多个线程之间相互协作的时候，就需要我们掌握Java线程的通信方式。本文将介绍Java线程之间的几种通信原理。</p>
<h5 id="5-1-锁与同步"><a href="#5-1-锁与同步" class="headerlink" title="5.1 锁与同步"></a>5.1 锁与同步</h5><ul>
<li>锁:一个锁同一时间只能被一个线程持有</li>
<li>同步:线程同步是线程之间按照一定的&#x3D;&#x3D;顺序执行&#x3D;&#x3D;</li>
</ul>
<p>无锁版本运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/**<br> * @ClassName : ThreadNoneLock<br> * @Description : 无锁版本<br> * @Author : dbin0123<br> * @Date: 2021-03-04 22:42<br> */<br>public class ThreadNoneLock &#123;<br><br>    public static void main(String[] args) &#123;<br>        Thread thread1 = new Thread(() -&gt; &#123;<br>            for (int i = 0; i &lt; 10; i++) &#123;<br>                System.out.println(Thread.currentThread().getName()+&quot;: &quot;+i);<br>            &#125;<br>        &#125;,&quot;线程1&quot;);<br><br><br>        Thread thread2 = new Thread(() -&gt; &#123;<br>            for (int i = 0; i &lt; 10; i++) &#123;<br>                System.out.println(Thread.currentThread().getName()+&quot;: &quot;+i);<br>            &#125;<br>        &#125;,&quot;线程2&quot;);<br><br>        thread1.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>响应(可能每次不一样)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">线程1: 0<br>线程1: 1<br>线程1: 2<br>线程2: 0<br>线程2: 1<br>线程2: 2<br>线程1: 3<br>线程1: 4<br>线程1: 5<br>线程1: 6<br>线程1: 7<br>线程1: 8<br>线程1: 9<br>线程2: 3<br>线程2: 4<br>线程2: 5<br>线程2: 6<br>线程2: 7<br>线程2: 8<br>线程2: 9<br></code></pre></td></tr></table></figure>

<p>需要线程1线执行完成后再执行线程2</p>
<ul>
<li>synchronized()实现(&#x3D;&#x3D;线程需要不断地去尝试获得锁&#x3D;&#x3D;)<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/**<br> * @ClassName : ThreadNoneLock<br> * @Description : 无锁版本<br> * @Author : dbin0123<br> * @Date: 2021-03-04 22:42<br> */<br>public class ThreadSync &#123;<br><br>    private static final Object lock = new Object();<br><br>    public static void main(String[] args) throws InterruptedException &#123;<br>        Thread thread1 = new Thread(() -&gt; &#123;<br>            //线程需要不断地去尝试获得锁<br>            synchronized (lock)&#123;<br>                for (int i = 0; i &lt; 10; i++) &#123;<br>                    System.out.println(Thread.currentThread().getName()+&quot;: &quot;+i);<br>                &#125;<br>            &#125;<br>        &#125;,&quot;线程1&quot;);<br><br><br>        Thread thread2 = new Thread(() -&gt; &#123;<br>            //线程需要不断地去尝试获得锁<br>            synchronized (lock)&#123;<br>                for (int i = 0; i &lt; 10; i++) &#123;<br>                    System.out.println(Thread.currentThread().getName()+&quot;: &quot;+i);<br>                &#125;<br>            &#125;<br>        &#125;,&quot;线程2&quot;);<br><br>        thread1.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
输出<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">线程1: 0<br>线程1: 1<br>线程1: 2<br>线程1: 3<br>线程1: 4<br>线程1: 5<br>线程1: 6<br>线程1: 7<br>线程1: 8<br>线程1: 9<br>线程2: 0<br>线程2: 1<br>线程2: 2<br>线程2: 3<br>线程2: 4<br>线程2: 5<br>线程2: 6<br>线程2: 7<br>线程2: 8<br>线程2: 9<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="5-2-等待-通知机制"><a href="#5-2-等待-通知机制" class="headerlink" title="5.2 等待&#x2F;通知机制"></a>5.2 等待&#x2F;通知机制</h5><p>Java多线程的等待&#x2F;通知机制是基于Object类的wait()方法和notify(), notifyAll()方法来实现的。</p>
<ol>
<li>notify()方法会随机叫醒一个正在等待的线程;</li>
<li>notifyAll()会叫醒所有正在等待的线程;</li>
</ol>
<p>++注意++</p>
<p>一个锁同一时刻只能被一个线程持有。而假如线程A现在持有了一个锁lock并开始执行，它可以使用lock.wait()让自己进入等待状态。这个时候，lock这个锁是被释放了的。</p>
<p>这时，线程B获得了lock这个锁并开始执行，它可以在某一时刻，使用lock.notify()，通知之前持有lock锁并进入等待状态的线程A，说“线程A你不用等了，可以往下执行了”,此时线程A的状态应该是:BLOCKED。</p>
<p>需要注意的是，这个时候线程B并没有释放锁lock，除非线程B这个时候使用lock.wait()释放锁，或者线程B执行结束自行释放锁，线程A才能得到lock锁。</p>
<p>示例(交替打印相同的数)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/**<br> * @ClassName : ThreadWaitNotify<br> * @Description : 线程的等待/通知机制(交替打印相同的数)<br> * @Author : dbin0123<br> * @Date: 2021-03-04 22:53<br> */<br>public class ThreadWaitNotify &#123;<br><br>    private static final Object lock = new Object();<br><br>    public static void main(String[] args) throws InterruptedException &#123;<br>        Thread thread1 = new Thread(() -&gt; &#123;<br>            synchronized (lock) &#123;<br>                for (int i = 0; i &lt; 5; i++) &#123;<br>                    try &#123;<br>                        System.out.println(&quot;Thread1: &quot; + i);<br>                        lock.notify();<br>                        lock.wait();<br>                    &#125; catch (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                lock.notify();<br>            &#125;<br>        &#125;,&quot;线程1&quot;);<br><br><br>        Thread thread2 = new Thread(() -&gt; &#123;<br>            synchronized (lock) &#123;<br>                for (int i = 0; i &lt; 5; i++) &#123;<br>                    try &#123;<br>                        System.out.println(&quot;Thread2: &quot; + i);<br>                        lock.notify();<br>                        lock.wait();<br>                    &#125; catch (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                lock.notify();<br>            &#125;<br>        &#125;,&quot;线程2&quot;);<br><br>        thread1.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Thread1: 0<br>Thread2: 0<br>Thread1: 1<br>Thread2: 1<br>Thread1: 2<br>Thread2: 2<br>Thread1: 3<br>Thread2: 3<br>Thread1: 4<br>Thread2: 4<br></code></pre></td></tr></table></figure>



<h5 id="5-3-信号量"><a href="#5-3-信号量" class="headerlink" title="5.3 信号量"></a>5.3 信号量</h5><p>JDK提供了一个类似于“信号量”功能的类Semaphore。但本文不是要介绍这个类，而是介绍一种基于volatile关键字的自己实现的信号量通信。</p>
<p><strong>&#x3D;&#x3D;volatile关键字能够保证内存的可见性，如果用volatile关键字声明了一个变量，在一个线程里面改变了这个变量的值，那其它线程是立马可见更改后的值的。&#x3D;&#x3D;</strong></p>
<p>让线程A输出0，然后线程B输出1，再然后线程A输出2…以此类推。我应该怎样实现呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/**<br> * @ClassName : ThreadVolatile<br> * @Description : volatile关键字(让线程A输出0，然后线程B输出1，再然后线程A输出2…以此类推)<br> * @Author : dbin0123<br> * @Date: 2021-03-04 23:04<br> */<br>public class ThreadVolatile &#123;<br><br>    private static volatile AtomicInteger num = new AtomicInteger(0);<br><br>    public static void main(String[] args) throws InterruptedException &#123;<br>        Thread thread1 = new Thread(() -&gt; &#123;<br>            for (int i = 0; i &lt; 10; i++) &#123;<br>                if (i % 2 == 0) &#123;<br>                    System.out.println(Thread.currentThread().getName() + &quot;: &quot; + num.getAndIncrement());<br>                &#125;<br>            &#125;<br>        &#125;, &quot;线程1&quot;);<br><br><br>        Thread thread2 = new Thread(() -&gt; &#123;<br>            for (int i = 0; i &lt; 10; i++) &#123;<br>                if (i % 2 == 1) &#123;<br>                    System.out.println(Thread.currentThread().getName() + &quot;: &quot; + num.getAndIncrement());<br>                &#125;<br>            &#125;<br>        &#125;, &quot;线程2&quot;);<br><br>        thread1.start();<br>        thread2.start();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>响应</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">线程1: 0<br>线程2: 1<br>线程1: 2<br>线程2: 3<br>线程1: 4<br>线程2: 5<br>线程1: 6<br>线程2: 7<br>线程1: 8<br>线程2: 9<br></code></pre></td></tr></table></figure>

<h5 id="5-5-join方法"><a href="#5-5-join方法" class="headerlink" title="5.5 join方法"></a>5.5 join方法</h5><p>使其他线程进入等待状态,是当前线程运行完成!</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">public class ThreadJoin &#123;<br><br>    public static void main(String[] args) throws InterruptedException &#123;<br>        Thread thread = new Thread(() -&gt; &#123;<br>            try &#123;<br>                System.out.println(&quot;我是子线程，我先睡一秒&quot;);<br>                Thread.sleep(1000);<br>                System.out.println(&quot;我是子线程，我睡完了一秒&quot;);<br>            &#125; catch (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        thread.start();<br>        thread.join();<br>        System.out.println(&quot;如果不加join方法，我会先被打出来，加了就不一样了&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="5-6-sleep方法"><a href="#5-6-sleep方法" class="headerlink" title="5.6 sleep方法"></a>5.6 sleep方法</h5><p>sleep方法是Thread类的一个静态方法。它的作用是让当前线程睡眠一段时间。它有这样两个方法：</p>
<ul>
<li>Thread.sleep(long)</li>
<li>Thread.sleep(long, int)</li>
</ul>
<p>这里需要强调一下：sleep方法是不会释放当前的锁的，而wait方法会。这也是最常见的一个多线程面试题。</p>
<p>它们还有这些区别：</p>
<ol>
<li>wait可以指定时间，也可以不指定；而sleep必须指定时间。</li>
<li>wait释放cpu资源，同时释放锁；sleep释放cpu资源，但是不释放锁，所以易死锁。</li>
<li>wait必须放在同步块或同步方法中，而sleep可以再任意位置</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.aiwiown.com">aiwiown</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.aiwiown.com/2021/03/06/2021/202103/2021-03-06-java_thread_101/">http://blog.aiwiown.com/2021/03/06/2021/202103/2021-03-06-java_thread_101/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.aiwiown.com" target="_blank">被讨厌的勇气</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/03/06/zEfkNQaWPJYIbAV.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/03/06/2021/202103/2021-03-06-java_thread_102/" title="2021年03月06日 《深入浅出 Java 多线程》第一篇 ThreadLocal类(附加)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2021年03月06日 《深入浅出 Java 多线程》第一篇 ThreadLocal类(附加)</div></div></a></div><div class="next-post pull-right"><a href="/2021/03/06/2021/202103/2021-03-06-java_thread_201/" title="2021年03月06日 《深入浅出 Java 多线程》第二篇 原理片-Java内存模型基础知识"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">2021年03月06日 《深入浅出 Java 多线程》第二篇 原理片-Java内存模型基础知识</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/03/06/2021/202103/2021-03-06-java_thread_102/" title="2021年03月06日 《深入浅出 Java 多线程》第一篇 ThreadLocal类(附加)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-06</div><div class="title">2021年03月06日 《深入浅出 Java 多线程》第一篇 ThreadLocal类(附加)</div></div></a></div><div><a href="/2021/03/06/2021/202103/2021-03-06-java_thread_201/" title="2021年03月06日 《深入浅出 Java 多线程》第二篇 原理片-Java内存模型基础知识"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-06</div><div class="title">2021年03月06日 《深入浅出 Java 多线程》第二篇 原理片-Java内存模型基础知识</div></div></a></div><div><a href="/2021/03/06/2021/202103/2021-03-06-java_thread_202/" title="2021年03月06日 《深入浅出 Java 多线程》第二篇 原理片-重排序与happens-before"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-06</div><div class="title">2021年03月06日 《深入浅出 Java 多线程》第二篇 原理片-重排序与happens-before</div></div></a></div><div><a href="/2021/03/06/2021/202103/2021-03-06-java_thread_203/" title="2021年03月06日 《深入浅出 Java 多线程》第二篇 原理片-volatile关键字"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-06</div><div class="title">2021年03月06日 《深入浅出 Java 多线程》第二篇 原理片-volatile关键字</div></div></a></div><div><a href="/2021/03/07/2021/202103/2021-03-07-java_thread_301/" title="2021年03月07日 《深入浅出 Java 多线程》第二篇 原理片-synchronized与锁"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-07</div><div class="title">2021年03月07日 《深入浅出 Java 多线程》第二篇 原理片-synchronized与锁</div></div></a></div><div><a href="/2021/03/08/2021/202103/2021-03-08-java_thread_302/" title="2021年03月08日 《深入浅出 Java 多线程》第二篇 工具-线程池(Executor ThreadPoolExecutor)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-08</div><div class="title">2021年03月08日 《深入浅出 Java 多线程》第二篇 工具-线程池(Executor ThreadPoolExecutor)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/03/06/zEfkNQaWPJYIbAV.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">aiwiown</div><div class="author-info__description">人生不是别人赋予的,而是自己选择的,自由就是被别人讨厌~</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">80</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">131</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">66</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/dbin0123"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/dbin0123" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:dbin0123@hotmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">第一章 进程与线程的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E8%BF%9B%E7%A8%8B%E4%BA%A7%E7%94%9F%E7%9A%84%E8%83%8C%E6%99%AF"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 进程产生的背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 上下文切换(&#x3D;&#x3D;程序计数器&#x3D;&#x3D;)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.</span> <span class="toc-text">第二章 Java多线程入门类和接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E7%BB%A7%E6%89%BFThread%E7%B1%BB-jdk8%E6%BC%94%E7%A4%BA-%E5%90%8E%E7%BB%AD%E4%BB%A3%E7%A0%81%E6%B2%A1%E6%9C%89%E7%89%B9%E6%AE%8A%E8%AF%B4%E6%98%8E%E9%83%BD%E4%BD%BF%E7%94%A8jdk8"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 继承Thread类(jdk8演示(后续代码没有特殊说明都使用jdk8))</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1-Thread-init%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1 Thread.init方法介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 实现Runnable接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-Callable%E3%80%81Future%E4%B8%8EFutureTask"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 Callable、Future与FutureTask</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Callable-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.3.1.</span> <span class="toc-text">Callable 接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Future%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.3.2.</span> <span class="toc-text">Future接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FutureTask%E7%B1%BB"><span class="toc-number">2.3.3.</span> <span class="toc-text">FutureTask类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#FutureTask%E7%9A%84%E5%87%A0%E4%B8%AA%E7%8A%B6%E6%80%81"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">FutureTask的几个状态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">2.4.</span> <span class="toc-text">第三章 线程组和线程优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E7%BA%BF%E7%A8%8B%E7%BB%84-ThreadGroup"><span class="toc-number">2.4.1.</span> <span class="toc-text">3.1 线程组(ThreadGroup)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">2.4.2.</span> <span class="toc-text">3.2 线程的优先级</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-%E7%BA%BF%E7%A8%8B%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.3.</span> <span class="toc-text">3.3 线程组的常用方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%8A%E4%B8%BB%E8%A6%81%E8%BD%AC%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.</span> <span class="toc-text">第四章 Java线程的状态及主要转化方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-Java%E7%BA%BF%E7%A8%8B%E7%9A%846%E4%B8%AA%E7%8A%B6%E6%80%81"><span class="toc-number">2.5.1.</span> <span class="toc-text">4.1 Java线程的6个状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-BLOCKED%E4%B8%8ERUNNABLE%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.5.2.</span> <span class="toc-text">4.2 BLOCKED与RUNNABLE状态的转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-WAITING%E7%8A%B6%E6%80%81%E4%B8%8ERUNNABLE%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.5.3.</span> <span class="toc-text">4.3 WAITING状态与RUNNABLE状态的转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-TIMED-WAITING%E4%B8%8ERUNNABLE%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.5.4.</span> <span class="toc-text">4.4 TIMED_WAITING与RUNNABLE状态转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD"><span class="toc-number">2.5.5.</span> <span class="toc-text">4.5 线程中断</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-Java%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">2.6.</span> <span class="toc-text">第五章 Java线程间的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-%E9%94%81%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">2.6.1.</span> <span class="toc-text">5.1 锁与同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">2.6.2.</span> <span class="toc-text">5.2 等待&#x2F;通知机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.6.3.</span> <span class="toc-text">5.3 信号量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-5-join%E6%96%B9%E6%B3%95"><span class="toc-number">2.6.4.</span> <span class="toc-text">5.5 join方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-6-sleep%E6%96%B9%E6%B3%95"><span class="toc-number">2.6.5.</span> <span class="toc-text">5.6 sleep方法</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/11/2024/202404/2024-04-11-Manjaro%E5%AE%89%E8%A3%85/" title="2024年04月11日 Manjaro安装">2024年04月11日 Manjaro安装</a><time datetime="2024-04-10T16:00:00.000Z" title="发表于 2024-04-11 00:00:00">2024-04-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/13/2023/202311/2023-10-23.%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88(Box,Rc,RefCell)/" title="2023年11月13日 智能指针(Box,Rc,RefCell)">2023年11月13日 智能指针(Box,Rc,RefCell)</a><time datetime="2023-11-12T16:00:00.000Z" title="发表于 2023-11-13 00:00:00">2023-11-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/23/2023/202310/2023-10-23.Cargo/" title="2023年10月23日 Cargo与crates.io">2023年10月23日 Cargo与crates.io</a><time datetime="2023-10-22T16:00:00.000Z" title="发表于 2023-10-23 00:00:00">2023-10-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/10/2023/202309/2023-09-10.%E7%BB%83%E4%B9%A0(minigrop%E7%A8%8B%E5%BA%8F)%20copy/" title="2023年09月10日 Rust 练习(minigrop程序)">2023年09月10日 Rust 练习(minigrop程序)</a><time datetime="2023-09-09T16:00:00.000Z" title="发表于 2023-09-10 00:00:00">2023-09-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/10/2023/202309/2023-09-25.%E9%97%AD%E5%8C%85/" title="2023年09月25日 闭包(closure)">2023年09月25日 闭包(closure)</a><time datetime="2023-09-09T16:00:00.000Z" title="发表于 2023-09-10 00:00:00">2023-09-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By aiwiown</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="3778678" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>